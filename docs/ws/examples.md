## Examples

Rather than sourcing the examples from the [Quick Start](../quick-start.md), these examples are real-world ones sourced from Bullet running on raw, user events generated by instrumentation on Yahoo sites.

!!! note "Real data!?"

    The actual data shown here has been edited and is not how actual Yahoo user events look.

!!! note "SQL translation"

    For each query, we will also rewrite it to a SQL like syntax for readability. Eventually, we plan the API to support this format as input so you could just write this in place of the JSON syntax.

### Simplest Query

The simplest query you can write would be:

**Bullet Query**

```javascript
{}
```
While not a very useful query - this will get any one event record (no filters => any record would be matched, no projection => gets the entire record, default aggregation => ```LIMIT```or ```RAW```, with size 1, default duration => 30000 ms), this can be used to quickly test your connection to Bullet.

**SQL**

```SQL
SELECT * FROM WINDOW(30000) LIMIT 1;
```

Since there is only one data stream in Bullet, the ```FROM``` clause is replaced with a ```WINDOW``` function that sets the time window for the Bullet query.

### Simple Filtering

**Bullet Query**

```javascript
{
   "filters":[
       {
           "field":"id",
           "operation":"==",
           "values":[
               "btsg8l9b234ha"
           ]
       }
    ]
}
```

**SQL**

```SQL
SELECT * FROM WINDOW(30s) WHERE id = "btsg8l9b234ha" LIMIT 1;
```

Because of the default constraints, this query would find at most 1 record with the id matching the value provided. The record would have all its fields.

A sample response could be (it has been edited to remove PII and other Yahoo data). The response contains a single matching record, and the associated meta information.

```javascript
{
   "records":[
       {
           "server_name":"EDITED",
           "page_uri":"/",
           "is_page_view":true,
           "device":"tablet",
           "debug_codes":{
               "http_status_code":"200"
           },
           "referrer_domain":"www.yahoo.com",
           "is_logged_in":true,
           "timestamp":1446842189000,
           "event_family":"view",
           "id":"btsg8l9b234ha",
           "os_name":"mac os",
           "demographics":{
               "age" : "25",
               "gender" : "m",
            }
       }
    ],
    "meta":{
        "rule_id":1167304238598842449,
        "rule_body":"{}",
        "rule_finish_time":1480723799550,
        "rule_receive_time":1480723799540
    }
}
```

### Relational Filters and Projections

**Bullet Query**

```javascript
{
    "filters":[
        {
            "field":"id",
            "operation":"==",
            "values":[
                "btsg8l9b234ha"
            ]
        },
        {
            "field":"page_id",
            "operation":"!=",
            "values":[
                "null"
            ]
        }
    ],
    "projection":{
        "fields":{
            "timestamp":"ts",
            "device_timestamp":"device_ts",
            "event":"event",
            "page_domain":"domain",
            "id":"id"
        }
    },
    "aggregation":{
        "type":"RAW",
        "size":10
    },
    "duration":20000
}
```
**SQL**

```SQL
SELECT timestamp AS ts, device_timestamp AS device_ts, event AS event, page_domain AS domain
FROM WINDOW(20s)
WHERE id = "btsg8l9b234ha" AND page_id IS NOT NULL
LIMIT 10;
```

The above query finds all events with id set to 'btsg8l9b234ha' and page_id is not null, projects out the fields listed above with their new names (timestamp becomes ts etc) and limits the results to at most 10 such records. ```RAW``` indicates that the complete raw record fields will be returned, and more complicated aggregations such as ```COUNT``` or ```SUM``` will not be performed. The duration would set the query to wait at most 20 seconds for records to show up.

The resulting response could look like (only 3 events were generated that matched the criteria):

```javascript
{
    "records": [
        {
            "domain": "http://some.url.com",
            "device_ts": 1481152233788,
            "id": 2273844742998,
            "event": "page",
            "ts": null
        },
        {
            "domain": "www.yahoo.com",
            "device_ts": 1481152233788,
            "id": 227384472956,
            "event": "click",
            "ts": 1481152233888
        },
        {
            "domain": "https://news.yahoo.com",
            "device_ts": null,
            "id": 2273844742556,
            "event": "page",
            "ts": null
        }
    ],
    "meta": {
        "rule_id": -3239746252817510000,
        "rule_body": "<entire rule body is re-emitted here>",
        "rule_finish_time": 1481152233799,
        "rule_receive_time": 1481152233796
    }
}
```

### Logical Filters and Projections

**Bullet Query**

```javascript
{
 "filters": [
                {
                    "operation": "OR",
                    "clauses": [
                        {
                            "operation": "AND",
                            "clauses": [
                                {
                                    "field": "id",
                                    "operation": "==",
                                    "values": ["c14plm1begla7"]
                                },
                                {
                                    "operation": "OR",
                                    "clauses": [
                                        {
                                            "operation": "AND",
                                            "clauses": [
                                                {
                                                    "field": "experience",
                                                    "operation": "==",
                                                    "values": ["web"]
                                                },
                                                {
                                                    "field": "page_id",
                                                    "operation": "==",
                                                    "values": ["18025", "47729"]
                                                }
                                            ]
                                        },
                                        {
                                            "field": "link_id",
                                            "operation": "RLIKE",
                                            "values": ["2.*"]
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "operation": "AND",
                            "clauses": [
                                {
                                    "field": "tags.player",
                                    "operation": "==",
                                    "values": ["true"]
                                },
                                {
                                    "field": "demographics.age",
                                    "operation": ">",
                                    "values": ["65"]
                                }
                            ]
                        }
                    ]
                }
            ],
 "projection" : {
    "fields": {
        "id": "id",
        "experience": "experience",
        "page_id": "pid",
        "link_id": "lid",
        "tags": "tags",
        "demographics.age": "age"
    }
 },
 "aggregation": {"type" : "RAW", "size" : 1},
 "duration": 60000
}
```

**SQL**

```SQL
SELECT id AS id, experience AS experience, page_id AS pid,
       link_id AS lid, tags AS tags, demographics["age"] AS age
FROM WINDOW(1min)
WHERE (id = "c14plm1begla7" AND ((experience = "web" AND page_id IN ["18025", "47729"])
                                 OR link_id MATCHES "2.*"))
      OR
      (tags["player"] AND demographics["age"] > "65")
LIMIT 1;
```

!!! note "Typing"

    If demographics["age"] was of type Long, then Bullet will convert 85 to be an Long, but in this example, we are pretending that it is String.  So, no conversion is made. Similarly for link_id, id, experience and page_id. tags is a Map of String to Boolean so Bullet converts ```"true"``` to the Boolean ```true```.

This query is looking for a single event with a specific id and either the page_id is in two specific pages on the "web" experience or with a link_id that starts with 2, or a player event where the age is greater than "65". In other words, it is looking for senior citizens who generate video player events or a particular person's (based on id) events on two specific pages or a group of pages that have link that have ids that start with 2. It then projects out only these fields with different names.

A sample result could look like (it matched because of tags.player was true and demographics.age was > 65):

```javascript
{
    "records": [
        {
            "pid":"158",
            "id":"0qcgofdbfqs9s",
            "experience":"web",
            "lid":"978500434",
            "age":"66",
            "tags":{"player":true}
        }
    ],
    "meta": {
        "rule_id": 3239746252812284004,
        "rule_body": "<RULE_BODY_EDITED_OUT>",
        "rule_finish_time": 1481152233805,
        "rule_receive_time": 1481152233881
    }
}
```


### GROUP ALL COUNT Aggregation
An example of a query performing a COUNT all records aggregation would look like:

**Bullet Query**

```javascript
{
   "filters":[
      {
         "field": "demographics.age",
         "operation": ">",
         "values": ["65"]
      }
   ],
   "aggregation":{
      "type": "GROUP",
      "attributes": {
         "operations": [
            {
               "type": "COUNT",
               "newName": "numSeniors"
            }
         ]
      }
   },
   "duration": 20000
}
```

**SQL**

```SQL
SELECT COUNT(*) AS numSeniors
FROM WINDOW(20s)
WHERE demographics["age"] > "65";
```

This query will count the number events for which demographics.age > 65. The aggregation type GROUP indicates that it is a group aggregation. To group by a key, the ```fields``` key needs to be set in the ```aggregation``` part of the query. If ```fields``` is empty or is omitted (as it is in the query above) and the ```type``` is ```GROUP```, it is as if all the records are collapsed into a single group - a ```GROUP ALL```. Adding a ```COUNT``` in the ```operations``` part of the ```attributes``` indicates that the number of records in this group will be counted, and the "newName" key denotes the name the resulting column "numSeniors" in the result. Setting the duration to 20000 counts matching records for
this duration.

A sample result would look like:

```javascript
{
    "records": [
        {
            "numSeniors": 363201
        }
    ],
    "meta": {}
}
```

This result indicates that 363,201 records were counted with demographics.age > 65 during the 20 s the query was running.


### GROUP ALL Multiple Aggregations

COUNT is the only GROUP operation for which you can omit a "field".

**Bullet Query**

```javascript
{
   "filters":[
      {
         "field": "demographics.state",
         "operation": "==",
         "values": ["california"]
      }
   ],
   "aggregation":{
      "type": "GROUP",
      "attributes": {
         "operations": [
            {
               "type": "COUNT",
               "newName": "numCalifornians"
            },
            {
               "type": "AVG",
               "field": "demographics.age",
               "newName": "avgAge"
            },
            {
               "type": "MIN",
               "field": "demographics.age",
               "newName": "minAge"
            },
            {
               "type": "MAX",
               "field": "demographics.age",
               "newName": "maxAge"
            }
         ]
      }
   },
   "duration": 20000
}
```

**SQL**

```SQL
SELECT COUNT(*) AS numCalifornians, AVG(demographics["age"]) AS avgAge,
       MIN(demographics["age"]) AS minAge, MAX(demographics["age"]) AS maxAge,
FROM WINDOW(20s)
WHERE demographics["state"] = "california";
```

A sample result would look like:

```javascript
{
    "records": [
        {
            "maxAge": 94.0,
            "numCalifornians": 188451,
            "minAge": 6.0,
            "avgAge": 33.71828
        }
    ],
    "meta": {
        "rule_id": 8051040987827161000,
        "rule_body": "<RULE BODY HERE>",
        "rule_finish_time": 1482371927435,
        "rule_receive_time": 1482371916625
    }
}
```

This result indicates that, among the records observed during the 20 s this query ran, there were 188,451 users with demographics.state equal to "california". Among these users the average age was 33.71828, the max age observed was 94, and the minimum age observed was 6.


### Exact COUNT DISTINCT Aggregation

**Bullet Query**

```javascript
{
  "aggregation": {
      "type": "COUNT DISTINCT",
      "fields": {
          "browser_name": "",
          "browser_version": ""
      }
    }
}
```

**SQL**

```SQL
SELECT COUNT(*) AS "COUNT DISTINCT"
FROM (SELECT browser_name, browser_version
      FROM WINDOW(30s)
      GROUP BY browser_name, browser_version) tmp;
```

This gets the count of the unique browser names and versions in the next 30 s (default duration). Note that we do not specify values for the keys in fields. This is because they are not relevant

```javascript
{
    "records": [
        {
            "COUNT DISTINCT": 158.0
        }
    ],
    "meta": {
        "rule_id": 4451146261377394443,
        "aggregation": {
            "standardDeviations": {
                "1": {
                    "upperBound": 158.0,
                    "lowerBound": 158.0
                },
                "2": {
                    "upperBound": 158.0,
                    "lowerBound": 158.0
                },
                "3": {
                    "upperBound": 158.0,
                    "lowerBound": 158.0
                }
            },
            "wasEstimated": false,
            "sketchFamily": "COMPACT",
            "sketchTheta": 1.0,
            "sketchSize": 1280
        },
        "rule_body": "<RULE BODY HERE>",
        "rule_finish_time": 1484084869073,
        "rule_receive_time": 1484084832684
    }
}
```

There were 158 unique combinations on browser names and versions in our dataset for those 30 s. Note the new ```aggregation``` object in the meta. It has various metadata about the result and Sketches. In particular, the ```wasEstimated``` key denotes where the result
was estimated or not. The ```standardDeviations``` key denotes the confidence at various sigmas: 1 (1 sigma = ~68% confidence, 2 sigma = ~95% confidence, 3 sigma = ~99% confidence). Since this result was not estimated, the result is the same as the upper and lower bounds for the result.


### Approximate COUNT DISTINCT Aggregation

**Bullet Query**

```javascript
{
  "aggregation": {
      "type": "COUNT DISTINCT",
      "fields": {
          "ip_address": ""
      },
      "attributes": {
          "newName": "uniqueIPs"
      }
    },
    "duration": 10000
}
```

**SQL**

```SQL
SELECT COUNT(*) AS uniqueIPs
FROM (SELECT ip_address
      FROM WINDOW(10s)
      GROUP BY ip_address) tmp;
```

This query gets us the unique IP addresses in the next 10 s. It renames the result column from "COUNT DISTINCT" to "uniqueIPs".

```javascript
{
    "records": [
        {
            "uniqueIPs": 130551.07952805843
        }
    ],
    "meta": {
        "rule_id": 5377782455857451480,
        "aggregation": {
            "standardDeviations": {
                "1": {
                    "upperBound": 131512.85413760383,
                    "lowerBound": 129596.30223107953
                },
                "2": {
                    "upperBound": 132477.15103015225,
                    "lowerBound": 128652.93906100772
                },
                "3": {
                    "upperBound": 133448.49248615955,
                    "lowerBound": 127716.46773622213
                }
            },
            "wasEstimated": true,
            "sketchFamily": "COMPACT",
            "sketchTheta": 0.12549877074343688,
            "sketchSize": 131096
        },
        "rule_body": "<RULE BODY HERE>",
        "rule_finish_time": 1484090240812,
        "rule_receive_time": 1484090223351
    }
}
```

The number of unique IPs in our dataset was 130551 in those 10 s (approximately) with the true value between (129596, 131512) at 68% confidence, (128652, 132477) at 95% confidence and (127716, 133448) at 99% confidence. In the *worst* case at 3 sigma (99% confidence),
our error is 2.17%. The final result was computed with 131096 bytes or ~128 KiB as denoted by ```sketchSize```. This happens to be maximum size the the COUNT DISTINCT sketch will take up at the default nominal entries, so even if we had billions of unique IPs, the size will be the same and the error may be higher (depends on the distribution). For example, the error when the same query was run for 30 s was 2.28% at 99% confidence (actual unique IPs: 559428, upper bound: 572514). In fact, the worst the error can get at this
Sketch size is 2.34% as defined [here](https://datasketches.github.io/docs/Theta/ThetaErrorTable.html), *regardless of the number of unique entries added to the Sketch!*.

### DISTINCT Aggregation

**Bullet Query**

```javascript
{
   "aggregation":{
      "type": "DISTINCT",
      "size": 10,
      "fields": {
         "browser_name": "browser"
      }
   }
}
```

**SQL**

```SQL
SELECT browser_name AS browser
FROM WINDOW(30s)
GROUP BY browser_name
LIMIT 10;
```

This query gets the distinct values for the browser_name field and limit the results to 10. It runs for 30 s.

```javascript
{
  "records":[
    {
      "browser":"opera"
    },
    {
      "browser":"flock"
    },
    {
      "browser":"links"
    },
    {
      "browser":"mozilla firefox"
    },
    {
      "browser":"dolfin"
    },
    {
      "browser":"lynx"
    },
    {
      "browser":"chrome"
    },
    {
      "browser":"microsoft internet explorer"
    },
    {
      "browser":"aol browser"
    },
    {
      "browser":"edge"
    }
  ],
  "meta":{
    "rule_id":-4872093887360741287,
    "aggregation":{
      "standardDeviations":{
        "1":{
          "upperBound":28.0,
          "lowerBound":28.0
        },
        "2":{
          "upperBound":28.0,
          "lowerBound":28.0
        },
        "3":{
          "upperBound":28.0,
          "lowerBound":28.0
        }
      },
      "wasEstimated":false,
      "uniquesEstimate":28.0,
      "sketchTheta":1.0
    },
    "rule_body":"<RULE_BODY_HERE>",
    "rule_finish_time":1485469087971,
    "rule_receive_time":1485469054070
  }
}
```

There were 28 unique results but we asked for 10, so the query returned a uniform sample across the 28 distinct values.

DISTINCT is just an alias for GROUP. A GROUP by with no operations is exactly a DISTINCT.

### GROUP by Aggregation

**Bullet Query**

```javascript
{
   "filters":[
      {
         "field": "demographics",
         "operation": "!=",
         "values": ["null"]
      }
   ],
   "aggregation":{
      "type": "GROUP",
      "size": 50,
      "fields": {
          "demographics.country": "country",
          "device": ""
      },
      "attributes": {
         "operations": [
            {
               "type": "COUNT",
               "newName": "count"
            },
            {
               "type": "AVG",
               "field": "demographics.age",
               "newName": "averageAge"
            },
            {
               "type": "AVG",
               "field": "timespent",
               "newName": "averageTimespent"
            }
         ]
      }
   },
   "duration": 20000
}
```

**SQL**

```SQL
SELECT demographics["country"] AS country, device AS device,
       COUNT(*) AS count, AVG(demographics["age"]) AS averageAge,
       AVG(timespent) AS averageTimespent
FROM WINDOW(20s)
WHERE demographics IS NOT NULL
GROUP BY demographics["country"], device
LIMIT 50;
```

This query groups by the country and the device and for each unique group gets the count, average age and time spent by the users for the next 20 seconds. It renames demographics.country to country and does not rename device. It limits the groups to 50. If there were more than
50 groups, the results would be a uniform sampling of the groups (but each group in the result would have the correct result). These parameters can all be tweaked [in the configuration](#configuration).

```javascript
{
  "records":[
    {
      "country":"uk",
      "device":"desktop",
      "count":203034,
      "averageAge":32.42523,
      "averageTimespent":1.342
    },
    {
      "country":"us",
      "device":"desktop",
      "count":1934030,
      "averageAge":29.42523,
      "averageTimespent":3.234520
    },
    <...and 41 other such records here>
  ],
  "meta":{
    "rule_id":1705911449584057747,
    "aggregation":{
      "standardDeviations":{
        "1":{
          "upperBound":43.0,
          "lowerBound":43.0
        },
        "2":{
          "upperBound":43.0,
          "lowerBound":43.0
        },
        "3":{
          "upperBound":43.0,
          "lowerBound":43.0
        }
      },
      "wasEstimated":false,
      "uniquesEstimate":43.0,
      "sketchTheta":1.0
    },
    "rule_body":"<RULE_BODY_HERE>",
    "rule_finish_time":1485217172780,
    "rule_receive_time":1485217148840
  }
}
```

We received 43 rows for this result. The maximum groups that was allowed for the instance of Bullet was 512. If there were more groups than the maximum specified by your configuration, **a uniform sample** across them would be chosen
for the result. However, for each group, the values computed (average, count) would be exact. The standard deviations, whether the result was estimated and the number of approximate uniques in the metadata would reflect the change.

If you asked for 50 rows in the aggregation (as the query did above) but there were more than 50 in the result (but < 512), the metadata would reflect the fact that the result was not estimated. You would still get a uniform sample
but by increasing your aggregation size higher, you could get the rest.

For readability, if you were just trying to get the unique values for a field or a set of fields, you could leave out the attributes section and specify your fields section. You could also call the type ```DISTINCT``` instead of
```GROUP``` to make that explicit. ```DISTINCT``` is just an alias for ```GROUP```. See [the DISTINCT example](#distinct-aggregation).
